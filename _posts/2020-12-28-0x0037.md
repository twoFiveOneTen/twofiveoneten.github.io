---
layout: post
title: "iOS开发strong、weak、unsafe_unretained区别"
date: 2020-12-28 15:05:00
categories: []
tags: []
---
在iOS开发中weak、strong都是ARC下常用的属性关键字，那unsafe_unretained又表示什么呢？它们有什么区别呢？
<!--more-->
# strong
strong表示对一块内存强引用，当strong类型的指针指向一块内存，这块内存的引用计数就加1，相反则减1。当一块内存的引用计数为0时则销毁这块内存。
看个例子：
```objective-c
__strong NSURL *url1 = [[NSURL alloc] initWithString:@"https://zkk.me"];
__strong NSURL *url2 = url1;
url1 = nil;
NSLog(@"url2 is %@", url2.absoluteString);
```
输出内容为
```
url2 is https://zkk.me
```
`[NSURL alloc]`分配了一块内存A（假设它叫A），strong类型的指针url1对内存A强引用，所有A的引用计数为1，后面strong类型的指针url2也指向了url1指向的内存A，所以A的引用计数再增加1，变为2。然后给url1赋值为nil，不再指向A，所以A的引用计数减1，变成了1，此时输出url2指向的内存A的内容。

# weak
weak表示一个指针对一块内存进行弱引用。弱引用就是不增加所指向内存的引用计数。
看个例子：
```objective-c
__strong NSURL *url1 = [[NSURL alloc] initWithString:@"https://zkk.me"];
__weak NSURL *url2 = url1;
url1 = nil;
NSLog(@"url2 is %@", url2.absoluteString);
```
输出内容为
```
url2 is (null)
```
由于url2是弱引用，所以不会增加引用计数，当url1被赋值为nil时，原来分配的内存的引用计数为0，则销毁这块内存，同时给url2指针也赋值为nil。所以输出为`(null)`

# unsafe_unretained
unsafe_unretained类型指针指向一块内存时，内存的引用计数也不会增加，这一点与weak一致。但是与weak类型不同的是，当其所指向的内存被销毁时，unsafe_unretained类型的指针并不会被赋值为nil，也就是变成了一个野指针。对野指针指向的内存进行读写，程序就会crash。

# 声明
在声明一个属性（property）时，可以直接用strong、weak、unsafe_unretained关键词，例如：
```objective-c
@property (nonatomic, strong) NSString *name;
@property (nonatomic, weak) NSString *address;
@property (nonatomic, unsafe_unretained) NSString *number;
```
但是当声明一个局部变量时，使用方式就有点区别，要在关键词前面加双下划线`__`，就像上面的例子中那样。

------------


> REFERENCE
- [__unsafe_unretained 的理解和使用](https://www.jianshu.com/p/bd6aa1e62717 "__unsafe_unretained 的理解和使用")